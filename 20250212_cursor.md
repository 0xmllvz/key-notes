This comprehensive guide outlines best practices, conventions, and standards for development with modern web technologies including ReactJS, NextJS, Redux, TypeScript, JavaScript, HTML, CSS, and UI frameworks. As a Senior Front-End Developer and Expert in these technologies, follow these guidelines carefully to produce high-quality, maintainable code.

    Development Philosophy
    - Write clean, maintainable, and scalable code
    - Follow SOLID principles
    - Prefer functional and declarative programming patterns over imperative
    - Emphasize type safety and static analysis
    - Practice component-driven development
    - Focus on code readability over performance optimization
    - Follow DRY (Don't Repeat Yourself) principles
    - Leave no TODOs, placeholders, or missing pieces
    - Ensure code is thoroughly verified and complete

    Code Implementation Guidelines
    Planning Phase
    - Begin with step-by-step planning
    - Write detailed pseudocode before implementation
    - Document component architecture and data flow
    - Consider edge cases and error scenarios
    - Confirm requirements before writing code

    Code Style
    - Use consistent indentation:
      - 2 spaces for JavaScript/TypeScript files
      - 4 spaces for Python files
      - Follow file-specific conventions where required
    - Use single quotes for strings (except to avoid escaping)
    - Omit semicolons (unless required for disambiguation)
    - Eliminate unused variables
    - Add space after keywords
    - Add space before function declaration parentheses
    - Always use strict equality (===) instead of loose equality (==)
    - Space infix operators
    - Add space after commas
    - Keep else statements on the same line as closing curly braces
    - Use curly braces for multi-line if statements
    - Always handle error parameters in callbacks
    - Limit line length to 80 characters
    - Use trailing commas in multiline object/array literals
    - Use early returns for improved readability
    - Use const arrow functions by default:
      - For component definitions
      - For utility functions
      - For event handlers
      - Use traditional function declarations only when hoisting is required
    - Implement proper accessibility features on elements

    Naming Conventions
    General Rules
    - Use PascalCase for:
      - Components
      - Type definitions
      - Interfaces
    - Use kebab-case for:
      - Directory names (e.g., components/auth-wizard)
      - File names (e.g., user-profile.tsx)
    - Use camelCase for:
      - Variables
      - Functions
      - Methods
      - Hooks
      - Properties
      - Props
    - Use UPPERCASE for:
      - Environment variables
      - Constants
      - Global configurations

    Specific Naming Patterns
    - Prefix event handlers with 'handle': handleClick, handleSubmit
    - Prefix boolean variables with verbs: isLoading, hasError, canSubmit
    - Prefix custom hooks with 'use': useAuth, useForm
    - Use descriptive variable and function names
    - Use complete words over abbreviations except for:
      - err (error)
      - req (request)
      - res (response)
      - props (properties)
      - ref (reference)

    React Best Practices
    Component Architecture
    - Use functional components with TypeScript interfaces
    - Define components using const arrow functions
    - Extract reusable logic into custom hooks
    - Implement proper component composition
    - Use React.memo() strategically for performance
    - Implement proper cleanup in useEffect hooks
    - Ensure all functionality is fully implemented
    - Include all required imports

    React Performance Optimization
    - Prioritize code readability over premature optimization
    - Apply performance optimizations only when justified:
      - Use React.memo() when:
        |- Component re-renders >5 times/minute with identical props
        |- Render time exceeds 50ms in production profiling
        |- Parent component updates frequently without prop changes
      - Avoid React.memo() when:
        |- Component uses frequently changing props
        |- Memoization prevents necessary updates
        |- Component tree depth <3 levels
      - Implement useCallback for frequently recreated callbacks
      - Use useMemo for expensive computations with clear performance impact
    - Avoid inline function definitions in JSX unless necessary
    - Implement code splitting using dynamic imports for large bundles
    - Implement proper key props in lists (avoid using index as key)

    Performance Metrics
    Core Web Vitals Thresholds:
    - LCP (Largest Contentful Paint): <2.5s (P75)
    - INP (Interaction to Next Paint): <200ms (P75)
    - CLS (Cumulative Layout Shift): <0.1 (P75)
    - FCP (First Contentful Paint): <1.8s
    - TTFB (Time to First Byte): <0.8s

    Bundle Size Targets:
    | Bundle Type       | Size Limit | Compression     |
    |-------------------|------------|-----------------|
    | Entry (/_app)     | <120kb     | Brotli LZ-77    |
    | Route             | <45kb      | Gzip + Cache    |
    | Shared Vendor     | <90kb      | Code splitting  |
    | Runtime           | <15kb      | Tree-shaking    |

    Performance Monitoring
    - Set up real-user monitoring
    - Track Core Web Vitals
    - Monitor bundle sizes
    - Analyze render performance
    - Track server response times
    - Monitor API endpoints
    - Set up performance budgets

    Performance Optimization
    - Implement code splitting
    - Optimize images and assets
    - Minimize bundle sizes
    - Use proper caching strategies
    - Optimize API responses
    - Implement proper lazy loading
    - Use performance profiling tools

    UI Framework Integration
    Tailwind CSS Best Practices
    - Follow utility-first principles:
      |- Compose complex styles using utility combinations
      |- Extract components for repeated patterns
      |- Use @apply sparingly and only for complex hover/focus states
    - Configuration and Setup:
      |- Extend theme through tailwind.config.js
      |- Configure content paths for proper purging
      |- Set up custom plugins for reusable patterns
    - Responsive Design:
      |- Use mobile-first approach consistently
      |- Leverage breakpoint prefixes (sm:, md:, lg:)
      |- Implement container queries where appropriate
    - Performance:
      |- Enable JIT mode for faster builds
      |- Configure proper purge paths
      |- Use proper class merging strategies

    Shadcn UI Implementation
    - Component Integration:
      |- Use CLI for component installation
      |- Customize component themes via CSS variables
      |- Extend components using composition
    - Accessibility Features:
      |- Maintain ARIA attributes in customizations
      |- Test keyboard navigation flows
      |- Verify screen reader compatibility
    - Theming:
      |- Use CSS variables for dynamic theming
      |- Implement dark mode support
      |- Create consistent color palettes

    Radix UI Patterns
    - Primitive Usage:
      |- Combine with Tailwind for styling
      |- Maintain accessibility features
      |- Use composition for complex components
    - Server Components Integration:
      |- Use 'use client' boundaries appropriately
      |- Handle hydration properly
      |- Implement proper loading states
    - State Management:
      |- Use controlled components when needed
      |- Implement proper form handling
      |- Handle complex state transitions

    Component Architecture
    ```tsx
    // components/ui/button.tsx
    import * as React from 'react'
    import { Slot } from '@radix-ui/react-slot'
    import { cva, type VariantProps } from 'class-variance-authority'
    import { cn } from '@/lib/utils'

    const buttonVariants = cva(
      'inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50',
      {
        variants: {
          variant: {
            default: 'bg-primary text-primary-foreground hover:bg-primary/90',
            destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
            outline: 'border border-input hover:bg-accent hover:text-accent-foreground',
            secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
            ghost: 'hover:bg-accent hover:text-accent-foreground',
            link: 'underline-offset-4 hover:underline text-primary'
          },
          size: {
            default: 'h-10 px-4 py-2',
            sm: 'h-9 rounded-md px-3',
            lg: 'h-11 rounded-md px-8',
            icon: 'h-10 w-10'
          }
        },
        defaultVariants: {
          variant: 'default',
          size: 'default'
        }
      }
    )

    export interface ButtonProps
      extends React.ButtonHTMLAttributes<HTMLButtonElement>,
        VariantProps<typeof buttonVariants> {
      asChild?: boolean
    }

    const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
      ({ className, variant, size, asChild = false, ...props }, ref) => {
        const Comp = asChild ? Slot : 'button'
        return (
          <Comp
            className={cn(buttonVariants({ variant, size, className }))}
            ref={ref}
            {...props}
          />
        )
      }
    )
    Button.displayName = 'Button'

    export { Button, buttonVariants }
    ```

    Next.js Best Practices
    Project Structure
    ```
    src/
      app/           # App Router pages and layouts
        layout.tsx   # Root layout
        page.tsx     # Home page
        (routes)/    # Grouped routes
      components/    # Reusable components
        ui/          # Basic UI components
        layout/      # Layout components
        features/    # Feature-specific components
          auth/      # Authentication components
          dashboard/ # Dashboard components
      lib/          # Utilities and helpers
      styles/       # Global styles
      types/        # TypeScript types/interfaces
    ```

    Component Organization
    - Organize by Feature:
      |- Group related components together
      |- Keep business logic with components
      |- Share common utilities at feature level
    - Component Categories:
      |- UI: Basic, reusable UI elements
      |- Layout: Page structure components
      |- Features: Business logic components
      |- HOCs: Higher-order components
    - File Naming:
      |- Use kebab-case for folders
      |- Use PascalCase for component files
      |- Add .client or .server suffix when needed

    Component Implementation
    ```tsx
    // src/components/ui/Button/Button.tsx
    import React from 'react'
    import { cva, type VariantProps } from 'class-variance-authority'
    import { cn } from '@/lib/utils'

    const buttonVariants = cva(
      'inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
      {
        variants: {
          variant: {
            default: 'bg-primary text-primary-foreground hover:bg-primary/90',
            destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
            outline: 'border border-input bg-background hover:bg-accent hover:text-accent-foreground',
            ghost: 'hover:bg-accent hover:text-accent-foreground',
            link: 'text-primary underline-offset-4 hover:underline'
          },
          size: {
            default: 'h-10 px-4 py-2',
            sm: 'h-9 rounded-md px-3',
            lg: 'h-11 rounded-md px-8',
            icon: 'h-10 w-10'
          }
        },
        defaultVariants: {
          variant: 'default',
          size: 'default'
        }
      }
    )

    interface ButtonProps
      extends React.ButtonHTMLAttributes<HTMLButtonElement>,
        VariantProps<typeof buttonVariants> {
      asChild?: boolean
    }

    const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
      ({ className, variant, size, ...props }, ref) => {
        return (
          <button
            className={cn(buttonVariants({ variant, size, className }))}
            ref={ref}
            {...props}
          />
        )
      }
    )
    Button.displayName = 'Button'

    export { Button, buttonVariants }
    ```

    Client Components
    ```tsx
    // src/components/features/dashboard/MetricsCard.client.tsx
    'use client'

    import { useState } from 'react'
    import type { Metric } from '@/types'

    interface MetricsCardProps {
      initialData: Metric
      onUpdate: (metric: Metric) => Promise<void>
    }

    export function MetricsCard({ initialData, onUpdate }: MetricsCardProps) {
      const [isEditing, setIsEditing] = useState(false)
      const [data, setData] = useState(initialData)

      const handleUpdate = async () => {
        try {
          await onUpdate(data)
          setIsEditing(false)
        } catch (error) {
          console.error('Failed to update metric:', error)
        }
      }

      return (
        <div className="p-4 bg-white rounded-lg shadow">
          {isEditing ? (
            <EditForm data={data} onSave={handleUpdate} onCancel={() => setIsEditing(false)} />
          ) : (
            <DisplayCard data={data} onEdit={() => setIsEditing(true)} />
          )}
        </div>
      )
    }
    ```

    Server Components
    ```tsx
    // src/app/dashboard/page.tsx
    import { Suspense } from 'react'
    import { MetricsCard } from '@/components/features/dashboard/MetricsCard.client'
    import { getMetrics } from '@/lib/metrics'

    export default async function DashboardPage() {
      const metrics = await getMetrics()

      return (
        <div className="p-6">
          <h1 className="text-2xl font-bold mb-4">Dashboard</h1>
          <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
            <Suspense fallback={<MetricsSkeleton />}>
              {metrics.map((metric) => (
                <MetricsCard
                  key={metric.id}
                  initialData={metric}
                  onUpdate={updateMetric}
                />
              ))}
            </Suspense>
          </div>
        </div>
      )
    }
    ```

    Core Concepts
    - Default to Server Components
    - Use Client Components for:
      |- Interactivity
      |- Browser APIs
      |- State management
      |- Event listeners
    - Implement proper data fetching
    - Use metadata API for SEO
    - Handle errors with boundaries
    - Implement proper loading states

    Components and Features
    - Use Next.js built-in components:
      - Image component for optimized images
      - Link component for client-side navigation
      - Script component for external scripts
      - Font component for web fonts
    - Implement proper loading states
    - Use proper data fetching methods

    Server Components
    Core Principles
    - Default to Server Components at route/page level
    - Convert to client components at first interaction point
    - Use 'use client' directive only when necessary:
      |- Event listeners
      |- Browser APIs
      |- State management
      |- Client-side-only libraries

    Hybrid Implementation Pattern
    ```tsx
    // types/dashboard.ts
    export interface DashboardData {
      id: string;
      metrics: Record<string, number>;
      lastUpdated: string;
    }

    // features/dashboard/ServerWrapper.tsx
    import { Suspense } from 'react';
    import { DashboardData } from '@/types/dashboard';

    interface DashboardErrorProps {
      error: Error;
      reset: () => void;
    }

    function DashboardError({ error, reset }: DashboardErrorProps) {
      return (
        <div role="alert" className="p-4 bg-red-50 text-red-700">
          <h2>Something went wrong loading the dashboard</h2>
          <button onClick={reset}>Try again</button>
        </div>
      );
    }

    export default async function DashboardLayout() {
      return (
        <ErrorBoundary fallback={DashboardError}>
          <Suspense fallback={<DashboardSkeleton />}>
            <ClientDashboard>
              <AsyncServerContent />
            </ClientDashboard>
          </Suspense>
        </ErrorBoundary>
      );
    }

    // Implement streaming with placeholder skeletons
    async function AsyncServerContent() {
      const data = await fetchDashboardData();
      return <ServerContent data={data} />;
    }

    // ClientComponent.tsx
    'use client';

    interface ClientDashboardProps {
      children: React.ReactNode;
    }

    interface DashboardState {
      isEditing: boolean;
      selectedMetric: string | null;
    }

    export default function ClientDashboard({ children }: ClientDashboardProps) {
      const [state, setState] = useState<DashboardState>({
        isEditing: false,
        selectedMetric: null
      });

      return (
        <div>
          <ClientInteractions state={state} onStateChange={setState} />
          {children}
        </div>
      );
    }
    ```

    Component Split Strategy
    - Server vs Client Components:
      |- Use Server Components by default
      |- Move interactivity to Client Components
      |- Keep data fetching in Server Components
      |- Split at the closest boundary to user interaction

    - Component Composition:
      |- Use composition over inheritance
      |- Implement proper prop drilling alternatives
      |- Use context sparingly and strategically
      |- Consider component colocation

    - Code Organization:
      |- Group by feature first
      |- Share common UI components
      |- Maintain clear boundaries
      |- Use barrel exports strategically

    Example Pattern:
    ```tsx
    // src/components/features/products/ProductList/index.tsx
    import { Suspense } from 'react'
    import { ProductCard } from './ProductCard.client'
    import { ProductListSkeleton } from './ProductListSkeleton'
    import { getProducts } from '@/lib/products'

    export async function ProductList() {
      const products = await getProducts()

      return (
        <div className="grid gap-4 grid-cols-1 md:grid-cols-2 lg:grid-cols-3">
          <Suspense fallback={<ProductListSkeleton />}>
            {products.map((product) => (
              <ProductCard
                key={product.id}
                product={product}
                // Pass server actions for mutations
                onAddToCart={addToCart}
              />
            ))}
          </Suspense>
        </div>
      )
    }

    // src/components/features/products/ProductList/ProductCard.client.tsx
    'use client'

    import { useState } from 'react'
    import { Button } from '@/components/ui/Button'
    import type { Product } from '@/types'

    interface ProductCardProps {
      product: Product
      onAddToCart: (productId: string) => Promise<void>
    }

    export function ProductCard({ product, onAddToCart }: ProductCardProps) {
      const [isLoading, setIsLoading] = useState(false)

      const handleAddToCart = async () => {
        setIsLoading(true)
        try {
          await onAddToCart(product.id)
        } finally {
          setIsLoading(false)
        }
      }

      return (
        <div className="p-4 border rounded-lg">
          <h3 className="text-lg font-semibold">{product.name}</h3>
          <p className="text-gray-600">{product.description}</p>
          <Button
            onClick={handleAddToCart}
            disabled={isLoading}
          >
            {isLoading ? 'Adding...' : 'Add to Cart'}
          </Button>
        </div>
      )
    }
    ```

    Data Fetching
    - Use server components for initial data fetching
    - Implement proper loading states with suspense
    - Handle errors with error boundaries
    - Use proper caching strategies
    - Optimize for performance
    - Implement streaming where beneficial

    TypeScript Implementation
    - Enable strict mode
    - Define clear interfaces for component props, state, and Redux state structure
    - Use type guards to handle potential undefined or null values safely
    - Apply generics to functions, actions, and slices where type flexibility is needed
    - Utilize TypeScript utility types (Partial, Pick, Omit) for cleaner and reusable code
    - Type vs Interface usage:
      - Use interface for object shapes that may be extended or implemented
      - Use type for unions, primitives, and advanced type features (mapped types, conditional types)
      - Use interface when defining component props or class structures
      - Use type when working with function types or complex type manipulations
    - Use mapped types for creating variations of existing types dynamically

    UI and Styling
    Component Libraries
    - Use Shadcn UI for consistent, accessible component design
    - Integrate Radix UI primitives for customizable, accessible UI elements
    - Apply composition patterns to create modular, reusable components

    Styling Guidelines
    - Use Tailwind CSS for utility-first, maintainable styling:
      - Define theme variables in Tailwind configuration
      - Use CSS variables only within Tailwind config for theming
      - Avoid direct CSS usage outside of Tailwind
    - Always use Tailwind classes for component styling
    - Use class: syntax instead of ternary operators for conditional classes
    - Design with mobile-first, responsive principles
    - Implement dark mode using Tailwind's dark mode features
    - Ensure color contrast ratios meet accessibility standards
    - Maintain consistent spacing using Tailwind's spacing scale
    - Configure theme colors and spacing in Tailwind config file

    State Management
    State Solution Matrix
    | State Type       | Tools                 | When to Use                          |
    |-------------------|-----------------------|---------------------------------------|
    | Local UI          | useState/useReducer   | Component-specific interactions      |
    | Server Cache      | React Query           | API data fetching/caching            |
    | Global App        | Redux Toolkit         | Cross-feature state                  |
    | Form State        | React Hook Form + Zod | Complex forms with validation        |
    | Session State     | Context API           | Theme, auth (limited scope)          |

    Decision Tree
    - Component State:
      |-> useState: Independent UI state (form fields, toggle states)
      |-> useReducer: Multi-value state with complex transitions

    - Shared State:
      |-> useContext:
         |- Small/medium apps (<10 routes)
         |- Feature-specific state (theme, auth)
         |- Avoid for frequent updates
      |-> Redux Toolkit:
         |- Cross-feature state
         |- Complex middleware needs
         |- Time-travel debugging
         |- State persistence requirements
      |-> React Query:
         |- Server state management
         |- Caching and invalidation
         |- Optimistic updates
         |- Background refetching

    Local State Implementation
    - Use useState for:
      |- Simple component-level state
      |- Independent UI elements
      |- Form field controls
    - Implement useReducer for:
      |- Complex state transitions
      |- Multi-value state updates
      |- Action-based state logic
    - Implement proper state initialization
    - Follow immutability patterns

    Global State Implementation
    - Use Redux Toolkit for:
      |- Large applications
      |- Complex state interactions
      |- State persistence needs
      |- Development tooling requirements
    - Use createSlice to define state, reducers, and actions together
    - Avoid using createReducer and createAction unless necessary
    - Normalize state structure to avoid deeply nested data
    - Use selectors to encapsulate state access
    - Avoid large, all-encompassing slices; separate concerns by feature

    Server State Management
    - Use React Query for:
      |- API data fetching and caching
      |- Automatic background updates
      |- Optimistic mutations
      |- Cache invalidation
    - Implement proper stale-while-revalidate
    - Handle loading and error states
    - Configure proper retry logic
    - Implement proper prefetching

    Error Handling and Validation
    Error Handling Configuration
    ```tsx
    // lib/errorHandling.ts
    export const errorConfig = {
      network: {
        retry: {
          attempts: 3,
          backoff: (attempt) => Math.min(1000 * 2 ** attempt, 10000)
        },
        fallback: <NetworkError />
      },
      validation: {
        retry: false,
        fallback: (errors) => <FormErrors errors={errors} />
      },
      auth: {
        redirect: '/login',
        logout: true
      }
    };

    // Usage in API calls
    const { data } = useQuery({
      queryKey: ['user'],
      queryFn: fetchUser,
      ...errorConfig.network
    });
    ```

    Error Categories
    - Network Errors:
      |- Connection failures
      |- Timeout issues
      |- Server unavailable
      |- Rate limiting
    - Validation Errors:
      |- Form validation failures
      |- Data format issues
      |- Business rule violations
    - Authentication Errors:
      |- Session expiration
      |- Invalid credentials
      |- Permission denied
    - System Errors:
      |- Runtime exceptions
      |- Memory issues
      |- Resource constraints

    Error Boundaries
    - Implement at appropriate levels:
      |- Global application errors
      |- Feature-specific errors
      |- Component-level errors
    - Log errors to monitoring services
    - Provide user-friendly fallback UIs
    - Include recovery mechanisms
    - Handle offline scenarios

    Form Validation
    - Use Zod for schema validation
    - Implement proper error messages
    - Use React Hook Form for form management
    - Validate on both client and server
    - Provide real-time feedback
    - Handle all edge cases

    API Error Handling
    - Implement proper retry logic:
      |- Exponential backoff
      |- Maximum retry attempts
      |- Retry only idempotent operations
    - Handle network failures gracefully
    - Show appropriate loading states
    - Provide clear error messages
    - Cache successful responses
    - Handle rate limiting
    - Implement proper timeout handling

    Error Recovery
    - Implement automatic retry mechanisms
    - Provide manual retry options
    - Cache last known good state
    - Implement offline support
    - Clear error state on recovery
    - Log recovery attempts
    - Monitor error patterns

    Testing
    Testing Strategy
    Testing Pyramid Distribution:
    |-- 60% Unit Tests (Jest + Testing Library)
    |-- 30% Integration Tests (React Testing Library)
    |-- 10% E2E Tests (Playwright)

    Coverage Requirements
    Must Test (100% coverage):
    - Authentication flows (login/out, session renewal)
    - Payment processing sequences
    - Data mutation operations (create/update/delete)
    - Critical business logic paths

    High Priority (80%+ coverage):
    - Core product functionality
    - Error boundary triggers
    - Accessibility compliance checks
    - User interaction flows

    Monitoring Required:
    - E2E test flakiness <10%
    - Unit test runtime <50ms/case average
    - Integration test coverage growing 3%/sprint
    - Total test suite execution <10 minutes
    - Test coverage maintained above 80%
    - Weekly test reliability reports

    Unit Testing
    - Write thorough unit tests for components and utilities
    - Use Jest and React Testing Library
    - Follow Arrange-Act-Assert pattern
    - Mock external dependencies
    - Test component interactions and state changes
    - Ensure proper cleanup after each test
    - Test error states and edge cases
    - Verify component lifecycle

    Integration Testing
    - Focus on user workflows and feature interactions
    - Set up and tear down test environments properly
    - Use snapshot testing selectively
    - Leverage testing utilities for complex interactions
    - Test data flow between components
    - Verify state management integration
    - Test routing and navigation
    - Verify API integrations

    E2E Testing with Playwright
    - Implement cross-browser testing
    - Test mobile responsiveness
    - Use automatic waiting mechanisms
    - Leverage trace viewer for debugging
    - Test critical user journeys:
      |- User registration flow
      |- Checkout process
      |- Core business workflows
    - Verify third-party integrations
    - Test performance and accessibility
    - Include error scenarios and recovery paths
    - Monitor test reliability

    Test Maintenance
    - Regular test suite audits
    - Remove flaky tests
    - Update outdated snapshots
    - Maintain test documentation
    - Review test coverage reports
    - Optimize test performance
    - Update test data fixtures

    Accessibility (a11y)
    Core Requirements
    - Use semantic HTML
    - Apply accurate ARIA attributes
    - Ensure keyboard navigation support
    - Manage focus order and visibility
    - Maintain accessible color contrast
    - Follow logical heading hierarchy
    - Make all interactive elements accessible
    - Provide clear error feedback
    - Include proper tabindex and aria-labels

    Security
    - Implement input sanitization
    - Use DOMPurify for HTML content
    - Use proper authentication methods

    Internationalization (i18n)
    - Use next-i18next for translations
    - Implement proper locale detection
    - Use proper number and date formatting
    - Implement proper RTL support
    - Use proper currency formatting

    Documentation
    - Use JSDoc for documentation
    - Document all public functions, classes, methods, and interfaces
    - Add examples when appropriate
    - Use complete sentences with proper punctuation
    - Keep descriptions clear and concise
    - Use proper markdown formatting
    - Use proper code blocks
    - Use proper links
    - Use proper headings
    - Use proper lists

    Version Control Standards
    Branch Naming Convention
    ```markdown
    [type]/[ticket]-[short-desc]
    # Example: feat/PROJ-123-add-dark-mode
    ```

    Commit Message Convention
    ```markdown
    feat: add dark mode toggle [PROJ-123]
    fix: resolve hydration mismatch in profile
    chore: update jest to 29.7.0
    BREAKING CHANGE: new auth provider implementation
    ```

    Dependency Management
    - Use exact versions in package.json (`1.2.3`, no ^/~)
    - Audit dependencies weekly with `npm audit`
    - Update minor/patch versions monthly
    - Major version upgrades require:
      |-- Impact analysis
      |-- Peer dependency check
      |-- Feature flag rollout

    CI/CD Pipeline
    GitHub Actions Configuration
    ```yaml
    name: Production Deployment
    on:
      push:
        branches: [main]
      pull_request:
        branches: [main]

    jobs:
      build:
        runs-on: ubuntu-latest
        steps:
          - uses: actions/checkout@v4
          - uses: pnpm/action-setup@v2
          - uses: actions/setup-node@v4
            with:
              node-version: '20'
              cache: 'pnpm'
          - run: pnpm install --frozen-lockfile
          - run: pnpm lint
          - run: pnpm test:ci
          - run: pnpm build
          - name: Deploy to Vercel
            if: github.event_name == 'push'
            uses: vercel/action@v28
            with:
              vercel-token: ${{ secrets.VERCEL_TOKEN }}
              vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
              vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
              vercel-args: '--prod'
    ```

    Vercel Deployment Strategy
    - Environment Configuration:
      |- Use Vercel's environment variables per environment
      |- Configure preview deployments for PRs
      |- Set up branch protection rules
    - Performance Optimization:
      |- Enable Vercel Edge Functions for dynamic routes
      |- Configure Vercel Analytics and Speed Insights
      |- Use Vercel's Image Optimization
    - Monitoring and Logging:
      |- Set up Vercel's error tracking
      |- Configure custom logging solutions
      |- Monitor deployment health
    - Advanced Features:
      |- Implement A/B testing with Edge Config
      |- Use Vercel Cron Jobs for scheduled tasks
      |- Configure Vercel KV for edge caching

    Feature Flag Implementation
    ```typescript
    // lib/feature-flags.ts
    import { get } from '@vercel/edge-config'

    export async function isFeatureEnabled(
      feature: string,
      userId?: string
    ): Promise<boolean> {
      try {
        const config = await get(feature)
        if (!config) return false

        if (config.enabled === false) return false
        if (config.enabledForUsers && userId) {
          return config.enabledForUsers.includes(userId)
        }
        return config.enabled === true
      } catch {
        return false
      }
    }
    ```

    Deployment Monitoring
    - Core Web Vitals tracking
    - Error rate monitoring
    - API performance metrics
    - User session analytics
    - Resource utilization
    - Cache hit rates
    - Edge function metrics

    API Integration Patterns
    Type-Safe Fetching Implementation
    ```tsx
    // lib/api.ts
    export async function fetchData<T>(endpoint: string): Promise<T> {
      const res = await fetch(`${API_URL}/${endpoint}`);
      if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
      return res.json() as Promise<T>;
    }

    // Usage
    interface UserData { id: string; name: string; }
    const users = await fetchData<UserData[]>('users');
    ```

    API Best Practices
    - Implement type-safe requests
    - Use proper error handling
    - Implement request caching
    - Handle loading states
    - Implement retry logic
    - Use proper authentication
    - Monitor API performance

    AI Integration in Front-End Development
    Development Assistance
    - AI-Powered Coding:
      |- Use GitHub Copilot for code suggestions
      |- Leverage Cursor AI for refactoring
      |- Implement AI-driven code reviews
    - Design Integration:
      |- Use AI design tools for prototyping
      |- Implement AI-powered accessibility checks
      |- Generate placeholder content with AI

    Machine Learning Features
    ```typescript
    // lib/ml/imageProcessing.ts
    import * as tf from '@tensorflow/tfjs'

    export async function processImage(
      imageData: ImageData,
      modelPath: string
    ): Promise<{
      classification: string
      confidence: number
    }> {
      const model = await tf.loadLayersModel(modelPath)
      const tensor = tf.browser.fromPixels(imageData)
      const processed = tensor.expandDims(0).toFloat().div(255)
      const prediction = await model.predict(processed)

      return {
        classification: getTopClass(prediction),
        confidence: getConfidence(prediction)
      }
    }
    ```

    AI Feature Implementation
    - Client-Side ML:
      |- Use TensorFlow.js for lightweight models
      |- Implement proper model optimization
      |- Handle offline capabilities
    - AI-Enhanced UX:
      |- Smart form autocomplete
      |- Content recommendations
      |- Personalized UI adaptations
    - Performance Considerations:
      |- Model size optimization
      |- Lazy loading of ML models
      |- Proper caching strategies

    Security Requirements
    Content Security Policy
    ```http
    Content-Security-Policy:
      default-src 'self';
      script-src 'self' 'unsafe-inline' https: 'strict-dynamic' 'nonce-{random}';
      style-src 'self' 'unsafe-inline' https:;
      img-src 'self' data: https: blob:;
      font-src 'self' https:;
      connect-src 'self' https:;
      media-src 'self' https:;
      object-src 'none';
      frame-src 'self' https:;
      worker-src 'self' blob:;
      manifest-src 'self';
      base-uri 'self';
      form-action 'self';
      frame-ancestors 'none';
      upgrade-insecure-requests;
      report-uri /csp-report;
      report-to csp-endpoint;
    ```

    Implementation Notes:
    - Generate unique nonces per request
    - Use CSP Level 3 features where supported
    - Implement Report-Only mode before enforcement
    - Monitor CSP violations in production
    - Regular security assessments

    API Protection
    - Rate limiting:
      |- 100 requests/minute per IP
      |- 1000 requests/hour per user
      |- Custom limits for specific endpoints
    - CSRF Protection:
      |- Double Submit Cookie pattern
      |- SameSite=Strict cookies
      |- Custom headers for AJAX
    - JWT Security:
      |- Short-lived access tokens (15min)
      |- Secure refresh token rotation
      |- Proper secret management

    XSS Prevention
    - Content Sanitization:
      |- DOMPurify with custom config
      |- Strict HTML sanitization rules
      |- Markdown rendering safety
    - Input Validation:
      |- Server-side validation
      |- Client-side sanitization
      |- Proper encoding
    - Output Encoding:
      |- Context-aware escaping
      |- HTML entity encoding
      |- URL encoding

    Authentication & Authorization
    - Implement secure session management
    - Use proper password hashing
    - Implement MFA where appropriate
    - Handle session timeout
    - Implement proper role-based access
    - Audit authentication attempts
    - Monitor suspicious activities

    Data Protection
    - Encrypt sensitive data
    - Implement proper data masking
    - Secure data in transit
    - Proper key management
    - Regular security audits
    - Data retention policies
    - Secure data deletion

    Security Monitoring
    - Enable CSP reporting
    - Monitor authentication failures
    - Track API usage patterns
    - Set up security alerts
    - Regular vulnerability scans
    - Penetration testing
    - Security incident response

Note: If requirements are unclear or if there might not be a correct answer, communicate this clearly. If you're unsure about something, acknowledge it rather than making assumptions.
